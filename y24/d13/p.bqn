#!bqn

# Decode binary string
ToIntâ†{
digitsâ†ğ•©-'0'
+Â´digitsÃ—10â‹†âŒ½â†•â‰ digits
}

IsDigitâ†{
  ('0'â‰¤ğ•©)Ã—ğ•©â‰¤'9'
}

NotEmptyâ†{ğ•©â‰¡""? âŸ¨âŸ© ; âŸ¨ğ•©âŸ©}
SplitDigitsâ†{
  ğ•Šğ•©: ""ğ•Šğ•© ;
  ğ•¨ğ•ŠâŸ¨âŸ©: NotEmpty ğ•¨ ;
  ğ•¨ğ•Šğ•©: Â¬IsDigitâŠ‘ğ•©? (NotEmpty ğ•¨)âˆ¾ ""ğ•Š 1â†“ğ•© ;
  ğ•¨ğ•Šğ•©: (ğ•¨âˆ¾âŠ‘ğ•©) ğ•Š 1â†“ğ•©
}

IsIntâ†0.001â‰¥|âˆ˜-âŸœ(âŒŠ0.5âŠ¸+)

# Split string on spaces using recursive fn
Splitâ†{
  ğ•Šğ•©: ""ğ•Šğ•© ;
  ğ•¨ğ•ŠâŸ¨âŸ©: âŸ¨ğ•¨âŸ© ;
  ğ•¨ğ•Šğ•©: ' '=âŠ‘ğ•©? âŸ¨ğ•¨âŸ© âˆ¾ ""ğ•Š 1â†“ğ•© ;
  ğ•¨ğ•Šğ•©: (ğ•¨âˆ¾âŠ‘ğ•©) ğ•Š 1â†“ğ•©
}

# Ugly 2x2 matrix math
Detâ†{âŸ¨a,b,c,dâŸ©:(aÃ—d)-bÃ—c}
Invâ†{âŸ¨a,b,c,dâŸ©:âŸ¨d,-b,-c,aâŸ©Ã·DetâŸ¨a,b,c,dâŸ©}
Mulâ†{âŸ¨a,b,c,dâŸ©ğ•ŠâŸ¨x,yâŸ©:âŸ¨(aÃ—x)+bÃ—y,(cÃ—x)+dÃ—yâŸ©}

part2â†0
Solveâ†{
  âŸ¨âŸ¨ax,ayâŸ©,âŸ¨bx,byâŸ©,âŸ¨gx,gyâŸ©âŸ©â†ToIntÂ¨Â¨ ğ•©
  invâ†(Inv âŸ¨ax,bx,ay,byâŸ©)
  {part2?âŸ¨gx,gyâŸ©+â†©10000000000000; 0}
  âŸ¨an,bnâŸ©â†inv MulâŸ¨gx,gyâŸ©
  { âŒˆÂ´IsIntâŸ¨an,bnâŸ© ? bn+3Ã—an ; 0}
}


Processâ†{
  ğ•ŠâŸ¨âŸ©: âŸ¨âŸ© ;
  ğ•Šğ•©: (Process 4â†“ğ•©) âˆ¾ Solve 3â†‘ğ•©
}

lsâ†â€¢FLines "input"
â€¢Show +Â´ Process SplitDigitsÂ¨ ls
